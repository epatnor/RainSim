<!-- public/index.html -->
<!DOCTYPE html>
<html lang="sv">
<head>
  <!-- # meta -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RainSim – 3D View</title>

  <!-- # styles -->
  <style>
    :root { --bg:#0b0e12; --card:#121824; --muted:#8ea3b8; }
    html,body{ margin:0; height:100%; background:var(--bg); color:#e5eef7; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif }
    .wrap{ display:grid; grid-template-columns: 360px 1fr; gap:16px; height:100vh; padding:16px; box-sizing:border-box }
    .left{ display:flex; flex-direction:column; gap:12px }
    .card{ background:var(--card); border-radius:14px; padding:14px; box-shadow:0 6px 20px rgba(0,0,0,.25) }
    h1{ margin:0 0 8px; font-size:18px }
    .row{ display:flex; gap:10px; align-items:center; margin:6px 0 }
    label{ display:block; font-weight:600; margin:10px 0 6px; color:#cfe2f5 }
    input[type=range]{ width:100% }
    .val{ min-width:56px; text-align:right; color:var(--muted) }
    .status{ display:flex; align-items:center; gap:8px; color:var(--muted) }
    .dot{ width:10px; height:10px; border-radius:50%; background:#ff6b6b }
    .dot.ok{ background:#58d68d }
    .btns{ display:flex; gap:8px; flex-wrap:wrap; margin-left:auto }
    button{ background:#1c2432; color:#eaf3ff; border:1px solid #2c3950; padding:8px 12px; border-radius:10px; cursor:pointer }
    button:hover{ border-color:#3d5170 }
    #viewport{ width:100%; height:100%; background:#0b0e12; border-radius:14px; overflow:hidden; position:relative }
    .credit{ position:absolute; right:10px; bottom:10px; color:#9fb2c7; font-size:12px; opacity:.8; user-select:none }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="left">
      <div class="card">
        <h1>Scene Controls (FastAPI)</h1>
        <div class="row">
          <div class="status"><span id="dot" class="dot"></span><span id="stat">Disconnected</span></div>
          <div class="btns">
            <button id="pullBtn">Pull</button>
            <button id="pushBtn">Push</button>
            <button id="autoBtn" data-on="0">Auto: Off</button>
          </div>
        </div>

        <label for="timeOfDay">Time of Day (h)</label>
        <div class="row"><input id="timeOfDay" type="range" min="0" max="24" step="0.01"><div class="val" id="v_timeOfDay"></div></div>

        <label for="exposure">Exposure</label>
        <div class="row"><input id="exposure" type="range" min="0.6" max="1.4" step="0.01"><div class="val" id="v_exposure"></div></div>

        <label for="fog">Fog Amount</label>
        <div class="row"><input id="fog" type="range" min="0" max="1" step="0.01"><div class="val" id="v_fog"></div></div>

        <label for="rain">Rain Intensity</label>
        <div class="row"><input id="rain" type="range" min="0" max="1" step="0.01"><div class="val" id="v_rain"></div></div>

        <label for="wetness">Surface Wetness</label>
        <div class="row"><input id="wetness" type="range" min="0" max="1" step="0.01"><div class="val" id="v_wetness"></div></div>

        <label for="cloudiness">Cloudiness</label>
        <div class="row"><input id="cloudiness" type="range" min="0" max="1" step="0.01"><div class="val" id="v_cloudiness"></div></div>

        <label for="wind">Wind (slant)</label>
        <div class="row"><input id="wind" type="range" min="0" max="1" step="0.01"><div class="val" id="v_wind"></div></div>
      </div>
    </div>

    <div id="viewport" class="card">
      <div class="credit">Three.js + FastAPI · Rain & Wet Shaders</div>
    </div>
  </div>

  <script type="module">
    // # imports
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js';

    // # ui refs
    const $ = (id)=>document.getElementById(id);
    const dot=$("dot"), stat=$("stat"), pullBtn=$("pullBtn"), pushBtn=$("pushBtn"), autoBtn=$("autoBtn");

    // # scene state
    const state = { timeOfDay:16, rain:0.4, wetness:0.5, fog:0.35, cloudiness:0.4, wind:0.3, exposure:1.0 };
    const keys = Object.keys(state);

    // # bind sliders
    for (const k of keys){
      const input = $(k), val = $(`v_${k}`);
      input.addEventListener("input", e=>{
        state[k] = Number(e.target.value);
        val.textContent = e.target.value;
        schedulePush();
      });
    }
    function syncUI(){
      for (const k of keys){ $(k).value = state[k]; $(`v_${k}`).textContent = state[k]; }
    }

    // # api helpers
    const BASE = "";
    function setStatus(ok){ dot.classList.toggle("ok", !!ok); stat.textContent = ok ? "Connected" : "Disconnected"; }
    async function apiGet(){
      try{ const r=await fetch(`${BASE}/api/scene`); if(!r.ok) throw 0; Object.assign(state, await r.json()); setStatus(true); syncUI(); }
      catch{ setStatus(false); }
    }
    async function apiPostAll(){
      try{ const r=await fetch(`${BASE}/api/scene`,{method:"POST",headers:{'Content-Type':'application/json'},body:JSON.stringify(state)}); if(!r.ok) throw 0; Object.assign(state, await r.json()); setStatus(true); syncUI(); }
      catch{ setStatus(false); }
    }
    async function apiPatch(delta){
      try{ const r=await fetch(`${BASE}/api/scene`,{method:"PATCH",headers:{'Content-Type':'application/json'},body:JSON.stringify(delta)}); if(!r.ok) throw 0; Object.assign(state, await r.json()); setStatus(true); syncUI(); }
      catch{ setStatus(false); }
    }

    // # buttons
    pullBtn.onclick = ()=> apiGet();
    pushBtn.onclick = ()=> apiPostAll();
    let auto=false, timer=null, pushDebounce=null, lastSent={...state};
    autoBtn.onclick = ()=>{
      auto=!auto; autoBtn.dataset.on=auto?'1':'0'; autoBtn.textContent=`Auto: ${auto?'On':'Off'}`;
      if(auto) timer=setInterval(apiGet, 1000); else { clearInterval(timer); timer=null; }
    };
    function schedulePush(){
      if(!auto) return;
      clearTimeout(pushDebounce);
      pushDebounce = setTimeout(()=>{
        const delta={}; for(const k of keys){ if(state[k]!==lastSent[k]) delta[k]=state[k]; }
        if(Object.keys(delta).length){ lastSent={...state}; apiPatch(delta); }
      }, 140);
    }

    // # three.js: renderer
    const host = $("viewport");
    const renderer = new THREE.WebGLRenderer({ antialias:false, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
    renderer.setSize(host.clientWidth, host.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    host.appendChild(renderer.domElement);

    // # scene/camera/fog
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x1a2330, 0.008);

    const camera = new THREE.PerspectiveCamera(60, host.clientWidth/host.clientHeight, 0.1, 1000);
    camera.position.set(10, 7, 12);
    camera.lookAt(0, 1.0, 0);

    // # lights
    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(10, 20, 10);
    scene.add(sun);

    const amb = new THREE.AmbientLight(0xffffff, 0.25);
    scene.add(amb);

    // # helper: sky color
    function skyColorAt(t, cloud){
      const day = Math.cos((t-12)*Math.PI/12)*0.5+0.5;
      const dusk = Math.exp(-((t-18)**2)/4.84)+Math.exp(-((t-6)**2)/4.84);
      const noon = new THREE.Color(0x7fb6ff);
      const night= new THREE.Color(0x0b1020);
      const duskC= new THREE.Color(0xffb36b);
      const c = new THREE.Color().copy(night).lerp(noon, day).lerp(duskC, Math.min(1,dusk));
      return c.lerp(new THREE.Color(0x3a4555), cloud*0.5);
    }

    // # wettable material hook
    function makeWettable(mat){
      mat.onBeforeCompile = (shader)=>{
        shader.uniforms.uWetness = { value: state.wetness };
        shader.uniforms.uRain    = { value: state.rain };
        shader.uniforms.uTime    = { value: 0.0 };

        shader.vertexShader = shader.vertexShader
          .replace('#include <common>', `
            #include <common>
            varying vec3 vPosW;
          `)
          .replace('#include <project_vertex>', `
            #include <project_vertex>
            vPosW = (modelMatrix * vec4(position,1.0)).xyz;
          `);

        shader.fragmentShader = shader.fragmentShader
          .replace('#include <common>', `
            #include <common>
            varying vec3 vPosW;
            uniform float uWetness;
            uniform float uRain;
            uniform float uTime;
          `)
          .replace('#include <output_fragment>', `
            vec3 worldNormal = inverseTransformDirection(normal, viewMatrix);
            float topness = saturate(dot(worldNormal, vec3(0.0, 1.0, 0.0)));
            float wet = uWetness * (0.35 + 0.65 * topness);
            float n = fract(sin(dot(vPosW.xz + uTime*0.1, vec2(12.9898,78.233))) * 43758.5453);
            wet *= mix(0.85, 1.1, n);
            vec3 wetColor = mix(diffuseColor.rgb, diffuseColor.rgb * 0.6, wet);
            float wetRough = clamp(roughnessFactor, 0.04, 1.0);
            wetRough = mix(wetRough, 0.06, wet);
            diffuseColor.rgb = wetColor;
            roughnessFactor = wetRough;
            #include <output_fragment>
          `);

        mat.userData.shader = shader;
      };
      return mat;
    }

    // # ground: “stenläggning” via upprepade UV och enkel färgvariation
    {
      const geo = new THREE.PlaneGeometry(60, 40, 1, 1);
      // fake-tiling i shader via worldpos → vi håller material enkelt
      const mat = makeWettable(new THREE.MeshStandardMaterial({
        color: 0x7f8992, roughness: 0.88, metalness: 0.02
      }));
      const ground = new THREE.Mesh(geo, mat);
      ground.rotation.x = -Math.PI/2;
      ground.position.y = 0;
      scene.add(ground);
    }

    // # house: kropp + tak + dörr/fönster
    {
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(4, 3, 3),
        makeWettable(new THREE.MeshStandardMaterial({ color:0xbfb8a6, roughness:0.85, metalness:0.0 }))
      );
      body.position.set(0, 1.5, 0);
      scene.add(body);

      const roof = new THREE.Mesh(
        new THREE.ConeGeometry(3.2, 1.6, 4),
        makeWettable(new THREE.MeshStandardMaterial({ color:0x70413c, roughness:0.7 }))
      );
      roof.rotation.y = Math.PI/4;
      roof.position.set(0, 3.6, 0);
      scene.add(roof);

      const door = new THREE.Mesh(
        new THREE.PlaneGeometry(0.9, 1.6),
        makeWettable(new THREE.MeshStandardMaterial({ color:0x4e575f, roughness:0.6 }))
      );
      door.position.set(1.1, 0.8, 1.51);
      scene.add(door);

      const win = new THREE.Mesh(
        new THREE.PlaneGeometry(0.9, 0.9),
        makeWettable(new THREE.MeshStandardMaterial({ color:0x6bb6ff, roughness:0.2 }))
      );
      win.position.set(-0.9, 1.4, 1.51);
      scene.add(win);
    }

    // # city wall + torn bakom huset
    {
      const wall = new THREE.Mesh(
        new THREE.BoxGeometry(60, 6, 1.2),
        makeWettable(new THREE.MeshStandardMaterial({ color:0x5b6672, roughness:0.9 }))
      );
      wall.position.set(0, 3, -12);
      scene.add(wall);

      for (let i=-2; i<=2; i++){
        const tower = new THREE.Mesh(
          new THREE.CylinderGeometry(1.1, 1.2, 8, 12),
          makeWettable(new THREE.MeshStandardMaterial({ color:0x56606b, roughness:0.85 }))
        );
        tower.position.set(i*12, 4, -12);
        scene.add(tower);
      }
    }

    // # postprocess: render + rain overlay
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const rainPass = new ShaderPass({
      uniforms:{
        tDiffuse:{ value:null },
        uTime:{ value:0 },
        uRain:{ value:state.rain },
        uWind:{ value:state.wind },
        uExposure:{ value:state.exposure }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){ vUv=uv; gl_Position=vec4(position.xy,0.0,1.0); }
      `,
      fragmentShader: `
        precision highp float;
        uniform sampler2D tDiffuse;
        uniform float uTime,uRain,uWind,uExposure;
        varying vec2 vUv;

        float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453); }
        float rainStreaks(vec2 uv, float t, float intensity, float slant){
          uv.x += slant * (uv.y*0.5);
          float d=0.0;
          for(int i=0;i<3;i++){
            float s=float(i+1);
            vec2 g = uv*vec2(1.0,6.0*s) + vec2(0.0,t*1.2*s);
            float f = fract(g.y + hash(floor(vec2(g.x,g.y))));
            float line = smoothstep(0.02,0.0,abs(f-0.5));
            d += line * (0.25 + 0.25*s);
            uv*=1.7;
          }
          return d*intensity;
        }
        vec3 tone(vec3 c,float e){ c*=e; return c/(c+vec3(1.0)); }
        void main(){
          vec3 base = texture2D(tDiffuse, vUv).rgb;
          float slant = mix(0.0, 0.35, uWind);
          float streak = rainStreaks(vUv, uTime*0.7, uRain, slant);
          vec3 rainTint = mix(vec3(0.0), vec3(0.12,0.16,0.20), clamp(uRain*0.9,0.0,1.0));
          vec3 col = base*(1.0 - uRain*0.08) + rainTint + vec3(streak)*0.12;
          gl_FragColor = vec4(tone(col,uExposure),1.0);
        }
      `
    });
    composer.addPass(rainPass);

    // # resize
    function onResize(){
      const w = host.clientWidth, h = host.clientHeight;
      renderer.setSize(w,h);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    addEventListener('resize', onResize);

    // # per-frame update (ljus, fog, uniforms)
    const tmpCol = new THREE.Color();
    function updateVisuals(){
      const t = state.timeOfDay;
      const elev = Math.cos((t-12)*Math.PI/12);
      const height = Math.max(0.0, elev);
      const azim = (t/24.0)*Math.PI*2.0;

      sun.position.set(Math.sin(azim)*20, 8 + height*30, Math.cos(azim)*20);
      sun.intensity = 0.2 + 1.4*height;
      amb.intensity = 0.15 + 0.35*Math.max(0.0,height);

      const sky = skyColorAt(t, state.cloudiness);
      renderer.setClearColor(sky, 1.0);
      scene.fog.color.copy(sky).lerp(tmpCol.set(0x16202c), state.cloudiness*0.5);
      scene.fog.density = 0.004 + state.fog*0.01 + state.rain*0.004;

      scene.traverse(o=>{
        if(o.isMesh && o.material && o.material.userData.shader){
          const sh = o.material.userData.shader;
          sh.uniforms.uWetness.value = state.wetness;
          sh.uniforms.uRain.value    = state.rain;
          sh.uniforms.uTime.value    = performance.now()*0.001;
          o.material.metalness = Math.min(0.25, state.wetness*0.15);
        }
      });

      rainPass.uniforms.uRain.value = state.rain;
      rainPass.uniforms.uWind.value = state.wind;
      rainPass.uniforms.uExposure.value = state.exposure;
      rainPass.uniforms.uTime.value = performance.now()*0.001;
    }

    // # loop
    function tick(){
      updateVisuals();
      composer.render();
      requestAnimationFrame(tick);
    }

    // # init
    onResize();
    syncUI();
    apiGet().then(()=>{ lastSent={...state}; });
    requestAnimationFrame(tick);
  </script>
</body>
</html>
